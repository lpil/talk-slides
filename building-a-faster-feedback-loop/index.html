<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>lpil - A Faster Feedback Loop</title>
  <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8">
</head>
  <body>
    <textarea id="source">
class: center, middle, inverse

# Building a Faster<br>Feedback Loop

Louis Pilfold<br>
http://lpil.uk/


???

Hi.

I'm Louis Pilfold, and I'm a exceptionally lazy developer.

Today I'd like to talk a little bit about my experience building a faster
feedback loop for Elixir development.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests pass<br>
GOTO 10<br>
<br>
<br>
<br>
<br>
<br>
<br>

???

This is my dev cycle.

I write a unit test.

I write some code.

The tests let me know if my implementation  has the
behaviour I expect.

For me this is much faster than checking in the REPL, and an
order of magnitude faster than actually running the app.

...

In reality it normally looks more like this.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

???

I write some code. The test fails.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>
<br>
<br>

???

I write some code. The test fails.

And again.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>

???

I write some code. The test fails.

And again.

And again.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
...<br>

???

And so on.

Every time I write more code I have to switch to another window to run the
tests. As we've established, I'm very lazy, so I want to get the computer to
do it for me.

Most languages will have a tool that will automatically run your tests for you
each time you save a source file in your project, solving this problem.

---
class: middle

<table class="centered">
  <tr><td>Haskell</td>   <td>=&gt;</td><td>Stack</td></tr>
  <tr><td>Ruby</td>      <td>=&gt;</td><td>Guard</td></tr>
  <tr><td>Erlang</td>    <td>=&gt;</td><td>Rebar autotest</td></tr>
  <tr><td>Javascript</td><td>=&gt;</td><td>Karma, Grunt, Gulp</td></tr>
  <tr><td>&nbsp;</td>    <td>     </td><td></td></tr>
</table>

???

Haskell has Stack.

Ruby has Guard.

Erlang has Rebar autotest.

Javascript has Karma.

But what did Elixir have?

---
class: middle

<table class="centered">
  <tr><td>Haskell</td>   <td>=&gt;</td><td>Stack</td></tr>
  <tr><td>Ruby</td>      <td>=&gt;</td><td>Guard</td></tr>
  <tr><td>Erlang</td>    <td>=&gt;</td><td>Rebar autotest</td></tr>
  <tr><td>Clojure</td>   <td>=&gt;</td><td>lein-test-refresh</td></tr>
  <tr><td>Javascript</td><td>=&gt;</td><td>Karma, Grunt, Gulp</td></tr>
  <tr><td>Elixir</td>    <td>=&gt;</td><td>???</td></tr>
</table>

???

Nothing.

When I started learning Elixir this was a problem for me, so I decided to make
this test runner one of my first Elixir projects. After some confusion about
processes and applications I had something that worked, and I've been using it
every day since.

I'm going to walk through two implementations, and then at the end maybe you'll
have some thoughts as to how we can make it better.

If at any point you'd like me to clarify anything please call out and let me
know. I'm very happy to answer questions.

---
class: middle
<pre>
When a file is saved -&gt;
  If the file is an Elixir file -&gt;
    Recompile the project
    Run the tests
</pre>
<br>

**fs** by Vladimir Kirillov and Maxim Sokhatsky<br>
[https://github.com/synrc/fs](https://github.com/synrc/fs)<br>
[https://hex.pm/packages/fs](https://hex.pm/packages/fs)

???
This is our method.

When a file is saved<br>
If the file is an Elixir file<br>
Recompile the project<br>
Run the tests<br>

Watching file system events to detect when a file has been changed is
definately the tricky part.

Luckily Vladimir and Maxim here have already done this for us, and released the
project as a hex package called fs.

---
class: middle

Subscribe to fs events

```ruby
iex&gt; Application.ensure_started(:fs)
#=&gt; :ok
iex&gt; :fs.subscribe()
#=&gt; :ok
```

...save a file...

```ruby
iex&gt; flush()
#
# {#PID&lt;0.119.0&gt;, {:fs, :file_event},
#  {'/home/louis/runner/lib/runner.ex', [:modified, :closed]}}
#=&gt; :ok
```

???

fs is an application that allows a process to subscribe to file system events.

Each time a file is modified fs will send the subscribed processes a message
containing information about the event, like so.

Let's build a GenServer process that will listen to these events.

---
class: middle

```ruby
defmodule Watcher do
  use GenServer

  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  # Callbacks

  def init(_) do
    :ok = Application.ensure_started(:fs)
    :ok = :fs.subscribe()
    {:ok, []}
  end

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    IO.puts "file changed: #{path}"
    {:noreply, state}
  end
end
```

???

First we have the public API.

There's just a start_link function which wraps the GenServer.start_link
function for neatness sake.

Then we have the GenServer callbacks.

We implement the init callback to ensure fs is started, subscribe to events,
and then start iteration.

We also implement a clause for the handle_info function that will match the events sent from fs.

From each message we grab the file path, and then print it.

---
class: middle

Start the Watcher GenServer

```ruby
iex> Watcher.start_link()
```

...edit a file...

```ruby
#=> "file changed: /home/louis/runner/lib/4913"
#=> "file changed: /home/louis/runner/lib/4913"
#=> "file changed: /home/louis/runner/lib/runner.ex~"
#=> "file changed: /home/louis/runner/lib/runner.ex"
#=> "file changed: /home/louis/runner/lib/runner.ex"
```

???

So if we start it in the REPL and edit a file, it works. It prints a series of
paths.

Now we can respond to file system events. Let's make it compile and run the
tests when it's an Elixir file that's changed.

---
class: middle

```ruby
defmodule Watcher do

  # Rest of module here...

  @pattern ~r/\.(exs|ex|erl|eex|xrl|yrl)\z/

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    if Regex.match?(@pattern, to_string(path) do
      Runner.run_tests()
    end
    {:noreply, state}
  end
end
```

???

Here's our updated handle_info clause.

First we check to see if the file has an Elixir or Erlang file extension using
a regex,

and if it matches we delegate the actual test running to a new Runner module.

In the real version we also ignore certain directories here, such as build and
deps.

So how does the run_tests/0 function run the tests?

---
class: middle, center, inverse, large

# Ports

???

Has anyone used Erlang Ports?

Ports are a way of running commands in the shell. Anything that is printed by
the command will be sent back to the process as a message.

---
```ruby
defmodule Runner do
  @args ~w(stream binary exit_status use_stdio)a
  def run_tests do
    {:spawn, "mix test"}
    |&gt; Port.open(@args)
    |&gt; results_loop
    :ok
  end

  defp results_loop(port) do
    receive do
      {^port, {:data, data}} -&gt;
        IO.write(data)
        results_loop(port)
      {^port, {:exit_status, status}} -&gt;
        status
    end
  end
end
```

???

Here's our function.
It creates a port that runs the command "mix test", and then enters a receive
loop.

When the message contains IO data, we print it and loop again. When it contains
an exit status the tests have finished running, so we return back to the
GenServer.

If you use this as it is, you will find that the tests will be run multiple
times when you save one file.

Even worse, if you edit files while the tests are running those will also add
more test runs to the queue, and you'll end up with tests running endlessly in
a loop.

This happens because there are actually many events occuring when a file is
saved, and our Watcher faithfully works through all the events in its inbox,
running the tests for each one.

---

```ruby
defmodule Watcher do

  # Rest of module here...

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    if Regex.match?(@pattern, to_string(path) do
      Runner.run_tests()
*     discard_messages() # Empty inbox after a test run
    end
    {:noreply, state}
  end

  def discard_messages do
    receive do
      _       -&gt; discard_messages()
      after 0 -&gt; :ok
    end
  end
end
```
???

My solution here was to empty the process inbox of any messages immediately
after running the tests.

To do so we simply enter a receive loop that does nothing for all messages.

This little after 0 trick allows us to stop iteration if there are no
messages left, rather than looping forever.

---
class: middle

```plain
iex&gt; Watcher.start_link()
:ok
iex&gt;
......................................................
................

Finished in 0.3 seconds (0.3s on load, 0.04s on tests)
74 tests, 0 failures, 4 skipped

Randomized with seed 387360
```

???

And that's pretty much how this test runner has worked for the last year and a
half. It's OK, it works. But what can we improve?

For starters this doesn't work on Windows. The shell on Linux isn't the same as
on Windows.

Also it's not as fast as it could be. Each time we run the tests we launch a
new instance of the BEAM, and then it has to load the bytecode and start the
applications.

Wouldn't it be great if we could avoid the shell altogether and just run the
tests inside the existing virtual machine?

How about we call the mix compile and mix test commands internally?

    </textarea>
    <script src="../vendor/remark-0.11.0.min.js"></script>
    <script>
var slideshow = remark.create({
  highlightStyle: "monokai",
  highlightLanguage: "remark",
  highlightLines: true,
});
    </script>
  </body>
</html>
