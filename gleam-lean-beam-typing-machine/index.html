<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>lpil - Gleam: Lean BEAM typing machine</title>
  <link rel="stylesheet" href="./style.css" type="text/css" charset="utf-8">
</head>
  <body>
    <textarea id="source">
class: middle, inverse, slide-purple

<br>
# Gleam: Lean BEAM typing machine

## Louis Pilfold<br>@louispilfold

???

I'm Louis, I've been a heavy user of Elixir and Erlang for about 5 years now.

I'm the founder of a small ad-tech company called Waive that uses Elixir for
everything, with a little Elm sprinkled on top.

I'm as a platform engineer at Nationwide Building Society, where mostly I work
with Go and Kubernetes.

I also do some open source work in the Erlang world:

I wrote Dogma, a style linter for Elixir, later succeeded by Credo, which
we're going to hear about later from Rene.

After that I wrote mix test.watch, an automated test runner for Elixir, and
exfmt, an Elixir auto-formatter that was succeeded by the official formatter
released in Elixir v1.6.

I've also done some work inside the Elixir compiler. For example I taught the
inspect protocol about colours, using this to add syntax highlighting to the
iex.

But today I'm not here to talk about any of those things, I'm here to talk
about Gleam!

What is Gleam?


---
## Hello, Gleam!
## TODO: Some graphic

???

Gleam has been the project consuming all of my time since the start of last
year.

Gleam is a new functional programming language for the BEAM. Like Elixir it
compiles to Erlang and adds no runtime overhead so we should always be to
match or sometimes even beat performance of typical Elixir and Erlang.

Gleam is intended to integrate well into the larger BEAM ecosystem, so it's
straightforward and zero cost to call Erlang and Elixir from Gleam, or to call
Gleam from Erlang and Elixir. We want to enrichen and contribute to the BEAM
ecosystem through collaboration, not fracture it.

Possibly the most distinct and interesting of Gleam's features is it's type
system. Gleam has a strong static type system inspired by ML family languages
such as Elm, Haskell, and Rust. I think this type system is where most the
value of Gleam can be found.


---
## Why Gleam?
???

---
class: middle
<img class="center-element" style="" src="img/demo.png">

---
class: slide-purple, middle
# What's next for Gleam?

???

Gleam's a new language and there's many things still to come, so what's coming
up next?

---
class: xl-code
## Function arguments

```rust
version.matches(
  "3.0.3",
  "3.0",
  False,
)
```
???

With functions that take multiple argument it can be difficult to difficult to
remember what the arguments are and which order they are expected in

This is especially true when reading unfamiliar code.


---
class: xl-code
## Labelled function arguments

```rust
version.matches(
  version: "3.0.3",
  requirement: "3.0",
  allow_pre: False,
)
```
???

Future versions of Gleam will have labelled arguments, a popular feature from
languages such as Python and OCaml.

With this feature arguments can optionally have names at the call site, making
it clearer what they are and allowing them to be given in any order.

Sometimes in Erlang and Elixir we will give arguments in a map or a keyword
list to name arguments, but there is a small performance penalt to this.

Gleam's labelled arguments will be resolved entirely at compile time and have
no performance cost.


---
class: center
## Windows support

<img class="center-element" style="max-width: 80%; padding-right: 7%" src="img/windows.png">

???

Linux and MacOS are popular with developers, but Windows is still the most
widely used desktop operating system in the world.

We want the barrier to entry to be as low as possible for users of all
operating systems, so having excellent Windows support is key.

This is especially important as many people who are new to programming will be
using Windows computers, and we want to make their learning journey as
frustration free as possible.


---
class: l-code center
## Exhaustiveness checking

```rust
enum Pet =
| Cat
| Dog
```

```rust
fn to_string(pet) {
  case pet {
  | Cat -> "kitty"
  | Dog -> "doggo"
  }
}
```

???

This feature is a personal favourite of mine and something that I'm really
looking forward to.

Let's say I've defined a Pet type in my codebase. It's an enum with 2
variants: Cat and Dog.

Elsewhere in my code I define a to_string function which pattern matches on a
pet and returns the string "kitty" for cats, and "doggo" for dogs.

---
class: l-code center
## Exhaustiveness checking

```rust
enum Pet =
| Cat
| Dog
| Tamagotchi
```

```rust
fn to_string(pet) {
  case pet {
  | Cat -> "kitty"
  | Dog -> "doggo"
  }
}
```

???

Shortly afterward a new craze takes the nation by storm, an electronic pet
called a Tamagotchi. Not wanting to be left behind I add a Tamagotchi variant
to the Pet enum and ship my code to production.

Sadly I've forgotten to update the `to_string` function, so later when the
function is called with the Tamagotchi variant no clause matches and the
process crashes, causing degraded functionality in my web application.

It's easy to see on this slide that the `to_string` function needs to be
updated, but in a codebase of tens or hundreds of thousands of lines of code
it's hard to find all the places that need to be updated when a new variant is
added.

Once Gleam has exhaustiveness checking this will kind of mistake will be
detected at compile time. It'll show the location of the incomplete pattern
match and show what values will cause the pattern match to crash, making this
kind of error impossible.


---
## Editor integration

<img class="center-element" style="" src="img/editors.png">

???

Productivity is a core value for Gleam, and the experience of the developer as
they read and write Gleam code is a big piece of this.

We want the experience of writing Gleam code to be as slick and enjoyable as
possible. We want IDE like features for Gleam in all the major editors, and by
implementing Language Server Protocol in the compiler we can get that.

Language Server Protocol is a standard developed by Microsoft for
communication between text editors and IDE engines. Once the Gleam compiler
implements it users of vim, emacs, atom, vs code and more will be able to:

Display type errors in editor after every keystroke.

Provide code completion options for variables, modules, functions, and so on.

Show documentation and type information on hover, as well as
jump-to-definition.

Perform language aware renaming of variables, functions, and more with a
single command

And every time the user saves we can automatically format the code, like with
Elixir's mix format command.

And what's more thanks to Gleam's type system and static analysis this tooling
will be able to provide much richer information to the programmer than is
possible with other BEAM languages.

---
## Documentation
<img class="center-element" alt="documentation" style="" src="img/documentation.png">

???

Another (perhaps more important) part of the developer experience puzzle is
documentation.

I don't know if anyone here has written a program in Gleam but right now it's
not as easy as it could be.

Unless you want to read the source code of the standard library or other
libraries there's no way to learn what modules and functions are available.

---
class: splash-image
<img src="img/hexdocs.png">

Meanwhile Elixir has the beautiful, searchable, mobile friendly documentation
generated from the code itself by the ex_doc tool, hosted on the hexdocs
website and linked directly to the hex package itself.

In Elixir it's easy to find the documentation you need, whether it's online,
in your editor, or on the command line, and we intend for this to be the case
for Gleam too.

Exactly what the best approach to take here is unclear, though we are
currently looking at whether we could use Elixir's ex_doc for Gleam.

This could be a great place someone to contribute a lot of value to Gleam,
especially someone comfortable working in Elixir.


---
class: center
## Exercism
<img class="center-element" style="max-width: 70%" src="img/exercism.png">

https://exercism.io

???

Who's familiar with Exercism?

---
class: middle

<img class="center-element" src="img/exercism-learn.png">
???
TODO: Replace the Ruby logo with Gleam's in this graphic

Exercism is a fantastic place to learn new programming languages and to
practice their coding skills.

How does it work? The programmer decides what language they want to practice
and Exercism gives them an exercise to complete.

Each exercises has instructions, and a full set of unit tests to make pass.


---
class: middle

<img class="center-element" style="padding-top: 69px" src="img/exercism-chat.png">


???

Once the programmer has completed their solution they can to submit it back to
Exercism, getting friendly and constructive feedback on their solution by
track mentors and other students.

They can also view solutions from other people and learn different approaches
to the same problem.


---
class: center

## 51 Languages and counting

<img class="center-element" src="img/exercism-languages.png">

???

Exercism has 51 languages tracks and has given the thumbs up for a Gleam
track.

Exercisms exercises need to be implemented for Gleam and documentation needs
to be written, but once done we'll have a top notch experience for learning
and practicing Gleam.

Exercism is community run, open source, and very well organised so if you're
interested in contributing to Gleam this could be a great place to create
help out.


---
class: center

## Future research

TODO: microscope graphic or something?

???

This next feature is still in the early ideas stage so don't get too attached.

If and when when this makes it into the language it may be completely
different.


---
## Ad hoc polymorphism

```elixir
defprotocol String.Chars do
  @spec to_string(t) :: String.t()
  def to_string(term)
end

defimpl String.Chars, for: Integer do
  def to_string(term) do
    Integer.to_string(term)
  end
end

defimpl String.Chars, for: Float do
  def to_string(term) do
    term |> :io_lib_format.fwrite_g() |> IO.iodata_to_binary()
  end
end
```
???

Today all functions in Gleam are monomorphic, it's not possible to write a
function that takes a list OR a map.

Another problem is that we can't take a function (behaviour) from a library
and make it work with types that we have defined. If someone writes a function
that takes a list we can't give it a new vector type that we have implemented,
even if conceptually a vector would work OK for what the function does.

Elixir solves this with protocols.

For example, Elixir's String.Char protocol allows the `to_string` function to
work on Lists, Atoms, Ints, Floats and more.

If we want the `to_string` function to work on new types that we have created
we can implement the protocol for that type.

---
## Ad hoc polymorphism

```rust
pub trait ToString {
  fn to_string(Self) -> String
}

let Int: ToString {
  fn to_string(term) {
    int.to_string(term)
  }
}


let Float: ToString {
  fn to_string(term) {
    term |> fwrite_g |> iodata.to_string
  }
}
```
???

Goals
- statically resolved at compile time
- works on all types, not just structs as in Elixir


---
## Ad hoc polymorphism

```rust
pub trait FromString {
  fn from_string(String) -> Result(Self, String)
}

let Int: FromString {
  fn from_string(s) {
    int.parse(s)
  }
}


let Float: FromString {
  fn from_string(s) {
    float.parse(s)
  }
}
```
???
can dispatch based on the return type

---
## Typed OTP libraries

```rust
pub struct Spec(arg, state, call, reply, cast) {
  init:
    fn(arg) -> Init(state)

  handle_call:
    fn(call, state) -> Call(reply, state)

  handle_cast:
    fn(cast, state) -> Cast(state)

  handle_info:
    fn(Any, state) -> Cast(state)
}
```
???

---
class: middle, slide-purple

### Find out more

- https://gleam.run
- https://github.com/lpil/gleam
- IRC `#gleam-lang` on Freenode

### Call me?

- twitter @louispilfold

???


    </textarea>
    <script src="../vendor/remark-0.14.0.min.js"></script>
    <script>
var slideshow = remark.create({
  highlightStyle: "monokai",
  highlightLanguage: "remark",
  highlightLines: true,
});
    </script>
    <!-- <link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet"> -->
  </body>
</html>
<!-- vi: ft=markdown
-->
