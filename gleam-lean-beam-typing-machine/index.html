<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>lpil - Gleam: Lean BEAM typing machine</title>
  <link rel="stylesheet" href="./style.css" type="text/css" charset="utf-8">
</head>
  <body>
    <textarea id="source">
class: middle, inverse, slide-purple

<br>
# Gleam: Lean BEAM typing machine

## Louis Pilfold<br>@louispilfold

???

---
class: slide-purple, middle
# What's next for Gleam?

???

Gleam's a new language and there's many things still to come, so what's coming
up next?

---
class: large-code
## Labelled function arguments

```rust
string.replace(subject, ",", " ")
```

```rust
date.new(2019, 10, 11)
```

```rust
file.write("hello", "program.log")
```

```rust
version.matches(
  "3.0.3",
  "3.0",
  False,
)
```
???

With functions that take multiple argument it can be difficult to difficult to
remember what the arguments are and which order they are expected in

This is especially true when reading unfamiliar code.


---
class: large-code
## Labelled function arguments

```rust
string.replace(subject, pattern: ",", with: " ")
```

```rust
date.new(year: 2019, month: 10, day: 11)
```

```rust
file.write(contents: "hello", to: "program.log")
```

```rust
version.matches(
  version: "3.0.3",
  requirement: "3.0",
  allow_pre: False,
)
```
???

Future versions of Gleam will have labelled arguments, a popular feature from
languages such as Python and OCaml.

With this feature arguments can optionally have names at the call site, making
it clearer what they are and allowing them to be given in any order.

Sometimes in Erlang and Elixir we will give arguments in a map or a keyword
list to name arguments, but there is a small performance penalt to this.

Gleam's labelled arguments will be resolved entirely at compile time and have
no performance cost.


---
## Windows support

TODO: graphic

???

Linux and MacOS are popular with developers, but Windows is still the most
widely used desktop operating system in the world.

We want the barrier to entry to be as low as possible for users of all
operating systems, so having excellent Windows support is key.

This is especially important as many people who are new to programming will be
using Windows computers, and we want to make their learning journey as
frustration free as possible.


---
## Editor integration

TODO: graphic showing the Gleam compiler talking to various different editors

???

- Display type errors in editor
- Code completion
- In-editor documentation
- Go to definition
- Renaming of variables, functions, etc
- Automated code formatting (like mix format)


---
class: splash-image
<img src="img/hexdocs.png">


---
## Ad hoc polymorphism (TBD)

```elixir
defprotocol String.Chars do
  @spec to_string(t) :: String.t()
  def to_string(term)
end

defimpl String.Chars, for: Integer do
  def to_string(term) do
    Integer.to_string(term)
  end
end

defimpl String.Chars, for: Float do
  def to_string(term) do
    term |> :io_lib_format.fwrite_g() |> IO.iodata_to_binary()
  end
end
```
???

Today all functions in Gleam are monomorphic, it's not possible to write a
function that takes a list OR a map.

Another problem is that we can't take a function (behaviour) from a library
and make it work with types that we have defined. If someone writes a function
that takes a list we can't give it a new vector type that we have implemented,
even if conceptually a vector would work OK for what the function does.

Elixir solves this with protocols.

For example, Elixir's String.Char protocol allows the `to_string` function to
work on Lists, Atoms, Ints, Floats and more.

If we want the `to_string` function to work on new types that we have created
we can implement the protocol for that type.

---
## Ad hoc polymorphism (TBD)

```rust
pub trait ToString {
  fn to_string(Self) -> String
}

let Int: ToString {
  fn to_string(term) {
    int.to_string(term)
  }
}


let Float: ToString {
  fn to_string(term) {
    term |> fwrite_g |> iodata.to_string
  }
}
```
???

Nothing here is concrete, this is still in the early ideas stage so if / when
this makes it into the language it may be completely different.

Goals
- statically resolved at compile time
- works on all types, not just structs as in Elixir


---
## Ad hoc polymorphism (TBD)

```rust
pub trait FromString {
  fn from_string(String) -> Result(Self, String)
}

let Int: FromString {
  fn from_string(s) {
    int.parse(s)
  }
}


let Float: FromString {
  fn from_string(s) {
    float.parse(s)
  }
}
```
???
can dispatch based on the return type

---
class: middle

## TODO: Exercism logo here

https://exercism.io

???

Who's familiar with Exercism?

---
class: middle

<img class="center-element" src="img/exercism-learn.png">
???
TODO: Replace the Ruby logo with Gleam's in this graphic

Exercism is a fantastic place to learn new programming languages and to
practice their coding skills.

How does it work? The programmer decides what language they want to practice
and Exercism gives them an exercise to complete.

Each exercises has instructions, and a full set of unit tests to make pass.


---
class: middle

<img class="center-element" style="padding-top: 69px" src="img/exercism-chat.png">


???

Once the programmer has completed their solution they can to submit it back to
Exercism, getting friendly and constructive feedback on their solution by
track mentors and other students.

They can also view solutions from other people and learn different approaches
to the same problem.


---
class: center

## 51 Languages and counting

<img class="center-element" src="img/exercism-languages.png">

???

Exercism has 51 languages tracks and has given the thumbs up for a Gleam
track.

Exercisms exercises need to be implemented for Gleam and documentation needs
to be written, but once done we'll have a top notch experience for learning
and practicing Gleam.

Exercism is community run, open source, and very well organised so if you're
interested in contributing to Gleam this could be a great place to create
help out.


---
class: middle, slide-purple

### Find out more

- https://gleam.run
- https://github.com/lpil/gleam
- IRC `#gleam-lang` on Freenode

### Call me?

- twitter @louispilfold

???


    </textarea>
    <script src="../vendor/remark-0.14.0.min.js"></script>
    <script>
var slideshow = remark.create({
  highlightStyle: "monokai",
  highlightLanguage: "remark",
  highlightLines: true,
});
    </script>
    <!-- <link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet"> -->
  </body>
</html>
<!-- vi: ft=markdown
-->
