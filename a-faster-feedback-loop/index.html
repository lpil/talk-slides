<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>lpil - A Faster Feedback Loop</title>
  <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8">
</head>
  <body>
    <textarea id="source">
class: center, middle, inverse

# A Faster Feedback Loop

Louis Pilfold<br>
http://lpil.uk/


???

Hi.

I'm Louis Pilfold, and I'm a exceptionally lazy developer.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests pass<br>
GOTO 10<br>
<br>
<br>
<br>
<br>
<br>
<br>

???

This is my dev cycle.

I write a unit test.

I write some code.

The tests let me know if my implementation  has the
behaviour I expect.

For me this is much faster than checking in the REPL, and an
order of magnitude faster than actually running the app.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

???

In reality it normally looks more like this.

I write some code. The test fails.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>
<br>
<br>

???

In reality it normally looks more like this.

I write some code. The test fails.

And again.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
<br>
<br>
<br>

???

In reality it normally looks more like this.

I write some code. The test fails.

And again.

And again.

---
class: center, middle

Write some unit tests<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
Write some code<br>
Tests **.red[FAIL]**<br>
...<br>

???

And so on.

Every time I write more code I have to switch to another window to run the
tests. As we've established, I'm very lazy, so I want to get the computer to
do it for me.

Most languages will have a tool that will automatically run your tests for you
each time you save a source file in your project, solving this problem.

---
class: middle

<table class="centered">
  <tr><td>Haskell</td>   <td>=&gt;</td><td>Stack</td></tr>
  <tr><td>Ruby</td>      <td>=&gt;</td><td>Guard</td></tr>
  <tr><td>Erlang</td>    <td>=&gt;</td><td>Rebar autotest</td></tr>
  <tr><td>Clojure</td>   <td>=&gt;</td><td>lein-test-refresh</td></tr>
  <tr><td>Javascript</td><td>=&gt;</td><td>Karma, Grunt, Gulp</td></tr>
  <tr><td>&nbsp;</td>    <td>     </td><td></td></tr>
</table>

???

Haskell has Stack.

Ruby has Guard.

Erlang has rebar autotest.

Clojure has the wordy lein-test-refresh.

Javascript has Karma, Grunt, Gulp and so on.

But what did Elixir have back when v1.0 was new?

---
class: middle

<table class="centered">
  <tr><td>Haskell</td>   <td>=&gt;</td><td>Stack</td></tr>
  <tr><td>Ruby</td>      <td>=&gt;</td><td>Guard</td></tr>
  <tr><td>Erlang</td>    <td>=&gt;</td><td>Rebar autotest</td></tr>
  <tr><td>Clojure</td>   <td>=&gt;</td><td>lein-test-refresh</td></tr>
  <tr><td>Javascript</td><td>=&gt;</td><td>Karma, Grunt, Gulp</td></tr>
  <tr><td>Elixir</td>    <td>=&gt;</td><td>???</td></tr>
</table>

???

Nothing.

"I'll have to write one" I thought.

So I did. And I've been using it every day since.

I'm going to walk you through roughly how it works.

Hopefully at the end you'll have some thoughts as to how we can make it better.

---
class: middle
<pre>
When a file is saved -&gt;
  If the file is an Elixir file -&gt;
    Recompile the project
    Run the "test" mix task
</pre>
<br>

[https://github.com/synrc/fs](https://github.com/synrc/fs)<br>
by Vladimir Kirillov and Maxim Sokhatsky

???
This is our method.

When a file is saved<br>
If the file is an Elixir file<br>
Recompile the project<br>
Run the "test" mix task<br>

Watching file system events to detect when a file has been changed is the
tricky part. Luckily Vladimir Kirillov and Maxim Sokhatsky have already done
this for us, and released the result on hex as `fs`.

---
class: middle

Subscribe to fs events

```ruby
iex&gt; Application.ensure_started(:fs)
#=&gt; :ok
iex&gt; :fs.subscribe()
#=&gt; :ok
```

...save a file...

```ruby
iex&gt; flush()
#
# {#PID&lt;0.119.0&gt;, {:fs, :file_event},
#  {'/home/louis/runner/lib/runner.ex', [:modified, :closed]}}
#=&gt; :ok
```

???

fs is an application that allows a process to subscribe to file system events.

Each time a file is modified it will send subscribed processes a message
containing information about the event, like so.

---
class: middle

```ruby
defmodule Watcher do
  use GenServer

  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  # Callbacks

  def init(_) do
    :ok = Application.ensure_started(:fs)
    :ok = :fs.subscribe()
    {:ok, []}
  end

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    IO.puts "file changed: #{path}"
    {:noreply, state}
  end
end
```

???

Here's our watcher GenServer.

In the init callback it subscribes to events from the fs application

And then it has a handle_info clause that will print take the path of the
changed file from the event, and then print.

We've also wrapped the GenServer.start_link function for neatness sake.

---
class: middle

Start the Watcher GenServer

```ruby
iex> Watcher.start_link()
```

...edit a file...

```ruby
#=> "file changed: /home/louis/runner/lib/4913"
#=> "file changed: /home/louis/runner/lib/4913"
#=> "file changed: /home/louis/runner/lib/runner.ex~"
#=> "file changed: /home/louis/runner/lib/runner.ex"
#=> "file changed: /home/louis/runner/lib/runner.ex"
```

???

And if we run this, it works. It prints a series of paths.

Now that we can respond to file system events let's make it compile and run the
tests when it's a source file.

---
class: middle

```ruby
defmodule Watcher do

  # Rest of module here...

  @source_file_pattern ~r/\.(exs|ex|erl|eex|xrl|yrl)\z/

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    if Regex.match?(@source_file_pattern, path) do
      Runner.run_tests()
    end
    {:noreply, state}
  end
end
```

???

Here's our updated handle_info clause.

First we check to see if the file has an Elixir or Erlang file extension using
a regex,

and if it matches we delegate the actual test running to a new Runner module.

In the real version we also ignore certain directories here, such as build and
deps.

So how does the run_tests/0 function run the tests?

---
class: middle, center, inverse, large

# Ports

???

Has anyone used Erlang Ports?

Ports are a way of running commands in the shell. Anything that is printed by
the command will be sent back to the process as a message.

---
```ruby
defmodule Runner do
  @args ~w(stream binary use_stdio stderr_to_stdout)a
  def run_tests do
    {:spawn, "mix test"}
    |&gt; Port.open(@args)
    |&gt; results_loop
    :ok
  end

  defp results_loop(port) do
    receive do
      {^port, {:data, data}} -&gt;
        IO.write(data)
        results_loop(port)
      {^port, {:exit_status, status}} -&gt;
        status
    end
  end
end
```

???

Here's our function.
It creates a port that runs the command "mix test", and then enters a receive
loop, printing the output from the tests running in the port.

This works. If you run this and edit a file the tests will run, and anything
printed will be streamed to the watcher and printed.

You will notice however that the tests will be run multiple times when you save
one file.

Even worse, if you edit files while the tests are running those will also add
more test runs to the queue, and you'll end up with tests running endlessly in
a loop.

This happens because there are actually many events occuring when a file is
saved, and our Watcher faithfully works through all the events in its inbox,
running the tests for each one.

---

```ruby
defmodule Watcher do

  # Rest of module here...

  def handle_info({_, {:fs, :file_event}, {path, _}}, state) do
    if Regex.match?(@source_file_pattern, path) do
      Runner.run_tests()
*     discard_messages() # Empty inbox after a test run
    end
    {:noreply, state}
  end

  def discard_messages do
    receive do
      _       -> discard_messages()
      after 0 -> :ok
    end
  end
end
```
???

My solution here was to empty the process inbox of any messages immediately
after running the tests.

To do so we simply enter a receive loop that does nothing for all messages.

This little after 0 trick allows us to stop iteration if there are no
messages left.

I found this technique in the source code for iex. It's very similar to the
flush method.

And that's pretty much how this tool has worked for the last year or so.

    </textarea>
    <script src="../vendor/remark-0.11.0.min.js"></script>
    <script>
var slideshow = remark.create({
  highlightStyle: "monokai",
  highlightLanguage: "remark",
  highlightLines: true,
});
    </script>
  </body>
</html>
